---
layout: single
title: "GO언어는?"

categories:
 - GO
---

## GO언어가 뭐지?
놀랍게도 만들어진지 10년이 지난 언어이다. 하지만 우리가 평소에 쓰는 Java나 C언어보다는 많은 사람들이 알고 있지 않다. <br>
우연히 GDSC 활동 중 GO 스터디에 들어갈 기회가 생겼고 찾아보았는데 최근 내가 관심있어 하는 블록체인과도 연관이 있다고 한다. <br>
앞으로 GO언어에 대해서 공부하고 내용을 써보려고 한다. 오늘은 GO 언어에 대한 장점들을 나열해보겠다. <br>

## GO의 장점
### 작고 단순하다
고는 배우거나 사용하기 쉽다. 그리고 다른 개발자도 읽기 쉬운 언어를 목표로 설계됐다. 그리고 다른 언어들과 비교하면 기능이 그렇게 많지는 않다. <br>
문법적으로는 C와 비슷해서 C 경험이 풍부한 개발자라면 비교적 쉽게 배울 수 있다. 아예 처음부터 배우는 것이 아닌, C를 바탕으로 공부할 수 있다. <br>
용량이 커도 컴파일이 몇 초만에 된다. 파일 및 라이브러리 등 C 스타일의 오버헤드 상당 부분이 거의 없다. <br>

고 언어에는 모두를 위한 무언가가 있다
고 문서는 고를 “동적 타입의 인터프리터 언어처럼 느껴지는, 빠른 정적 타입의 컴파일 언어”라고 설명한다. 실제로 용량이 큰 고 프로그램도 몇 초 안에 컴파일된다. 또한 고는 파일 및 라이브러리 등 C 스타일의 오버헤드 상당 부분이 거의 없다. 고의 특징은 다음과 같다. 

• 편의성: 고는 일반적인 프로그래밍 요구를 충족시킨다는 측면에서 파이썬 같은 스크립팅 언어와 흔히 비교된다. 동시성, ‘고루틴(goroutines)’ 등 고의 기능 중 일부는 언어 자체에 내장돼 있으며, 추가적인 기능은 고의 ‘http 패키지’와 같은 고 표준 라이브러리 패키지로 제공된다. 고는 파이썬과 마찬가지로 가비지 수집을 포함한 자동 메모리 관리 기능을 지원한다.

파이썬 등의 스크립팅 언어와 달리 고 코드는 빠르게 실행되는 네이티브 바이너리로 컴파일된다. 또한 C나 C++과 달리 고의 컴파일 속도는 매우 빨라서 고로 작업하다 보면 컴파일 언어보다는 스크립팅 언어를 쓰는 느낌이 들 정도다. 아울러 고 빌드 시스템은 다른 컴파일 언어보다 덜 복잡하다. 

• 속도: 고 바이너리의 실행 속도는 C보단 느리지만 속도 차이는 대부분의 애플리케이션에서 무시할 만한 수준이다. 대부분의 작업에서 고의 성능은 C와 대등하며, 일반적으로 개발 속도로 유명한 다른 언어(예: 자바스크립트(JavaScript), 파이썬, 루비(Ruby) 등)보다 훨씬 빠르다.

• 이식성: 고 툴체인으로 생성된 실행 파일은 기본적인 외부 종속성 없이 단독으로 실행할 수 있다. 고 툴체인은 다양한 운영체제 및 하드웨어 플랫폼에서 사용할 수 있으며, 여러 플랫폼에서 바이너리를 컴파일하는 데 쓸 수 있다.

• 상호운용성: 고는 기반 시스템 액세스를 희생하지 않고 이 모든 장점을 제공한다. 고 프로그램은 외부 C 라이브러리와 통신하거나 네이티브 시스템 호출을 수행할 수 있다. 예를 들어 도커에서 고는 저수준 리눅스 함수, 컨트롤 그룹, 네임스페이스와 연결하여 컨테이너를 활용할 수 있다.

• 지원: 고 툴체인은 리눅스, 맥OS, 윈도우 바이너리 또는 도커 컨테이너로 무료 제공된다. 고는 레드햇 엔터프라이즈 리눅스(Red Hat Enterprise Linux)와 페도라(Fedora) 등 여러 인기 리눅스 배포판에 기본으로 포함돼 있어 고 소스를 이런 플랫폼에 배치하기 비교적 용이하다. 마이크로소프트 비주얼 스튜디오 코드(Microsoft Visual Studio Code)부터 액티브스테이트(ActiveState)의 코모도 IDE(Komodo IDE)까지 많은 서드파티 개발 환경에서도 고 지원은 탄탄하다.

고 언어가 가장 적합한 곳
사실 모든 작업에 다 맞는 언어는 없지만 더 많은 종류의 작업에 적합한 언어는 있다. 고는 다음의 애플리케이션 유형을 개발할 때 가장 빛을 발한다.

• 클라우드-네이티브 개발
고의 동시성 및 네트워킹 기능, 높은 수준의 이식성은 클라우드 네이티브 앱을 개발에 적합하다. 실제로 고는 도커, 쿠버네티스, 이스티오 등 여러 클라우드 네이티브 컴퓨팅의 기반을 구축하는 데 사용됐다.

• 분산형 네트워크 서비스
네트워크 애플리케이션의 핵심은 동시성이며, 고의 네이티브 동시성 기능(예: 고루틴 및 채널)은 이런 작업에 적합하다. 많은 고 프로젝트가 API, 웹 서버, 웹 애플리케이션을 위한 최소 프레임워크 등 네트워킹, 분산형 기능, 클라우드 서비스에 쓰이는 이유다. 

• 유틸리티 및 독립형 도구
고 프로그램은 외부 종속성이 최소화된 상태에서 바이너리로 컴파일된다. 그래서 유틸리티 및 기타 도구 제작에 이상적이다. 빠르게 실행되고 재배포를 위해 신속하게 패키지화할 수 있어서다. 텔레포트(Teleport, SSH용)라는 액세스 서버를 한 예로 들 수 있다. 텔레포트는 소스부터 컴파일하거나 사전 구축 바이너리를 다운로드하여 쉽고 빠르게 서버에 배치할 수 있다.

고 언어의 한계
고의 기능은 찬사와 비판이 공존한다. 고는 작고 이해하기 쉽게 고안됐기 때문에 특정 기능이 의도적으로 누락됐다. 그 결과, 다른 언어에서는 일반적인 몇몇 기능이 고에서는 의도적으로 제공되지 않는다.

오래된 불만 중 하나는 함수가 다양한 유형의 변수를 수용할 수 있는 총칭 제네릭의 부재였다. 수년 동안 고 개발팀은 제네릭 추가를 반대했다. 하지만 2022년 초에 공개된 고 1.18부터 제네릭 구문이 도입됐다. 고는 상당한 고심 끝에 주요 기능을 드물게 추가하지만 여러 버전에서 광범위한 호환성을 유지한다.

고의 또 다른 단점은 생성되는 바이너리의 크기다. 고 바이너리는 정적으로 컴파일되기 때문에 런타임에 필요한 모든 요소가 바이너리 이미지에 포함돼 있다. 이 접근 방식은 빌드 및 배포 프로세스를 간소화하지만, 그 대신 64비트 윈도우에서 간단한 ‘Hello, world!’를 출력하는 바이너리의 크기도 약 1.5MB에 육박한다는 단점이 있다.

고 개발팀은 후속 릴리즈마다 이런 바이너리의 규모를 줄이고 있다. 또 압축이나 고의 디버그 정보를 삭제하여 고 바이너리를 줄일 수 있다. 이 마지막 옵션은 서비스 실행 실패 시 디버그 정보를 유용하게 쓸 수 있는 클라우드 또는 네트워크 서비스보다는 독립형 분산형 앱에 적합하다.

고가 자랑하는 기능인 자동 메모리 관리도 가비지 수집에 일정량의 처리 오버헤드를 필요로 하기 때문에 (보기에 따라서는) 단점이 될 수 있다. 고는 수동 메모리 관리를 제공하지 않으며, 고의 가비지 수집은 엔터프라이즈 애플리케이션에서 나타나는 종류의 메모리 부하를 효과적으로 처리하지 못한다는 비판을 받고 있다.

하지만 고의 새로운 버전은 메모리 관리 기능을 개선하는 것으로 보인다. 예를 들면 고 1.8은 가비지 수집 지연 시간이 크게 짧아졌다. 고 개발자들은 C 확장 기능 또는 서드파티 수동 메모리 관리 라이브러리를 통해 수동 메모리 할당을 사용할 수 있다. 물론 대부분의 고 개발자는 네이티브 솔루션을 선호한다.

데스크톱 애플리케이션의 GUI와 같은 풍부한 GUI를 고 애플리케이션에 적용하는 소프트웨어 문화가 여전히 파편화돼 있는 것도 단점이다. 대부분의 고 애플리케이션은 명령줄 도구 또는 네트워크 서비스다. 그래도 다양한 프로젝트가 고 애플리케이션에 풍부한 GUI를 적용하고 있다. 이를테면 GTK 및 GTK3 프레임워크를 위한 바인딩이 있고, C 바인딩을 활용하고 순수한 고로 작성되진 않았지만 플랫폼 네이티브 UI를 제공하고자 하는 프로젝트도 있다. 윈도우 사용자라면 워크(Walk)를 사용해 볼 수도 있다. 

하지만 이 영역에서 명확한 승자나 장기적으로 안정적인 프로젝트는 아직 등장하지 않았으며, 크로스 플랫폼 GUI 라이브러리를 구축하는 등의 일부 구글 프로젝트는 도중에 실패했다. 아울러 고는 기본적으로 플랫폼 독립적이기 때문에 이런 요소가 표준 패키지 세트에 포함될 가능성이 작다.

고는 네이티브 시스템 함수와 통신할 수 있지만 커널 또는 장치 드라이버 등의 저수준 시스템 구성 요소나 임베디드 시스템을 개발하기 위한 목적으로는 설계되지 않았다. 결국 고 애플리케이션을 위한 고 런타임과 가비지 수집은 기반 OS에 의존하고 있다(이런 종류의 작업을 위한 언어에 관심이 있다면 러스트(Rust) 언어를 살펴보자).

고 언어의 미래
앞으로 고의 발전 방향은 개발자들의 요구 사항에 따라 결정될 가능성이 높다. 고의 개발팀도 완고하게 굴기보다는 개발자들을 의견을 더 많이 수용하는 쪽으로 바뀌고 있다. 결국 언어에 추가된 제네릭이 좋은 예다.

2021년 고 개발자 조사에서 고 사용자들은 해당 언어가 제공하는 기능에 매우 만족하고 있는 것으로 나타났지만 많은 개선 여지를 언급하기도 했다. 고 사용자가 원했던 주요 개선 사항으로는 의존성 관리(고의 지속적인 문제점), 버그 진단, 신뢰성이 있었다. 이 밖에 메모리, CPU 사용량, 바이너리 크기, 빌드 타임 등도 지적됐다. 

대부분의 언어는 주요 사용 사례에 끌려간다. 고가 등장한 지 10년이 흘렀고, 이 언어의 틈새시장은 네트워크 서비스가 됐으며, 입지를 계속해서 확대할 가능성이 높다. 대체로 고와 관련해 언급된 주요 사용 사례는 API 또는 RPC 서비스 개발(49%)이었다. 데이터 처리(10%), 웹 서비스(10%), CLI 애플리케이션(8%)이 그 뒤를 이었다.

고 언어의 매력이 커지고 있다는 또 다른 징후는 이를 선택하는 개발자의 수다. 고 사용을 고려했다고 밝힌 응답자의 75%가 이 언어를 선택했다. 고를 선택하지 않은 사람들은 러스트(25%), 파이썬(17%), 자바(12%)를 꼽았다. 각 언어는 다른 틈새를 찾았거나 찾고 있다. 러스트는 안전하고 빠른 시스템 프로그래밍을 위한 것이고, 파이썬은 프로토타입 구성, 자동화, 글루 코드를 위한 것이며, 자바는 오래된 엔터프라이즈 애플리케이션을 위한 것이다.

고의 속도 및 개발 단순성이 다른 사용 사례에 얼마나 적용될지 또는 고가 엔터프라이즈 개발에 얼마나 깊이 침투할지는 두고 봐야 할 일이다. 하지만 주요 프로그래밍 언어로서 고의 미래는 이미 확실해졌다. 특히 클라우드에서 고의 속도와 간결성을 통해 장기적으로 유지보수할 수 있는 확장형 인프라를 쉽게 개발할 수 있다.

원문보기:
https://www.ciokorea.com/news/250552#csidx3b8a26bbd1558ceb098eb1ec43086cb 
