---
layout: single
title: "C# 프로그래밍 4번째 시간 - 연산자"
categories:
  - C# Study
---

## 유니티의 네걸음, C# 공부시작 22일차

오늘은 C#에서 기본적이지만 매우 중요한 ***연산자***에 대해서 배우겠습니다! <br><br>

### 1.수식 연산자 (+, -, *, /, %)

덧셈, 뺄셈, 곱셈, 나눗셈, 그리고 나머지를 구하는 연산자가 있습니다. 이것을 표로 정리해보겠습니다.

분류|기능|예시
---|---|---
+ |양쪽 피연산자를 서로 더한다|a + b
- |왼쪽 피연산자에서 오른쪽 피연산자를 뺀다|a - b
* |양쪽 피연산자를 서로 곱한다|a * b
/ |왼쪽 피연산자를 오른쪽 피연산자로 나눈다|a / b
% |왼쪽 피연산자를 오른쪽 피연산자로 나눈 뒤의 나머지를 구한다|a % b

피연산자는 연산의 대상을 의미합니다. a+b에서 a,b는 피연산자, +는 연산자입니다.

수식연산자를 이용해서 예제를 만들어보겠습니다.

#### [수식 연산자를 활용한 예제]
```c#
using System;

namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 55, b = 4;
			Console.WriteLine("{0} + {1} = {2}", a, b, a + b);
			Console.WriteLine("{0} - {1} = {2}", a, b, a - b);
			Console.WriteLine("{0} * {1} = {2}", a, b, a * b);
			Console.WriteLine("{0} / {1} = {2}", a, b, a / b);
			Console.WriteLine("{0} % {1} = {2}", a, b, a % b);
		}
	}
} 
```

이에 대한 결과는
```
55 + 4 = 59 <br>
55 - 4 = 51 <br>
55 * 4 = 220 <br>
55 / 4 = 13 <br>
55 % 4 = 3 <br>
```
가 나올것입니다.
 
 
 
진짜 말 그대로 기본적인 연산을 해주는 것입니다. 여기서 궁금증이 발생하는데, <br>

왜 55에서 4를 나눴을때의 값은 13.75가 아니라 13만 출력될까요? <br>

프로그래밍에서는 정수 간의 나눗셈은 항상 정수로만 표시됩니다. <br>

이에 따라 a,b가 int여서 발생한 현상인데, 이 둘 중 하나만 <U>실수 타입(float,double,decimal)</U>로 변환해주면 소수점도 출력가능합니다. <br>
 
여기서 a,b 중 하나를 실수타입으로 초기화해도 되지만,
이를 간단하게 만드려면 
```
Console.WriteLine("{0} / {1} = {2}", a, b, a / (double)b);
Console.WriteLine("{0} / {1} = {2}", a, b, (a + 0.0) / b);
Console.WriteLine("{0} / {1} = {2}", a, b, 1.0 * a / b);
 ```

이런 방식을 이용해도 됩니다.

### 2.수식 연산자 (++, --)

증감연산자는 피연산자의 값을 1 증가시키거나 1 감소시키는 증가 감소 연산자가 있습니다.

분류|기능|예시
---|---|---
++ (전위 증가 연산자) |피연산자의 값을 1만큼 증가|++a;
-- (전위 감소 연산자) |피연산자의 값을 1만큼 감소|--a;
++ (후위 증가 연산자) |피연산자의 값을 1만큼 증가|a++;
-- (후위 감소 연산자) |피연산자의 값을 1만큼 감소|a--;

이 표를 활용하여 증감연산자를 사용한 예제를 만들어보겠습니다.

#### [증감연산자를 이용한 예제]
```c#
using System;

namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 1;
			Console.WriteLine(++a); // a의 값을 1 증가시키고, a의 값을 출력 (a = 2)
			Console.WriteLine(a++); // a의 값을 출력한 뒤, a의 값을 1 증가 (a = 3)
			Console.WriteLine(--a); // a의 값을 1 감소시키고, a의 값을 출력 (a = 2)
			Console.WriteLine(a--); // a의 값을 출력한 뒤, a의 값을 1 감소 (a = 1)
			}
	}
}
  ```
  
이에 따른 결과는 

2 2 2 2 가 나옵니다.

*전위* 라고 붙은 연산자는 피연산자의 값을 먼저 증가, 감소하고 문장을 실행합니다.

반대로 *후위* 라고 붙은 연산자는 문장을 먼저 실행시키고 뒤에서 값을 증가하고 감소합니다.
<br>
 

증감연산자를 처음보면 어려울 수 있어서 추가 예시를 하나 들어보겠습니다.

ex) a => 2, b => 3일때, 연산식의 결과를 생각해봅시다.
```
1. (a++) + b

2. (a++) + (- -b)

3. (++a) + (a++)
```
(1) 답은 5입니다. a에서 후위 증가 연산자를 이용하여 계산이 끝나고 a의 값이 증가합니다.

즉, 출력을 할때는 a의 값의 증가를 처리하기 전입니다. 따라서 2+3=5로 나옵니다.

(2) 답은 4입니다. a에서 후위 증가 연산자를 이용하였고, b는 전위 감소 연산자를 이용하여,

출력을 하기전 b는 계산이 되고, a는 계산되지 않았습니다. 따라서 2+2=4로 나옵니다.

(3) 답은 6입니다. 맨 처음에 a에서 전위 증가 연산자를 이용하여 출력하기 전에 계산이 됩니다.

근데, 다음 a에서는 이미 앞에 a가 +1된 형태이기 때문에 그 형태에서 후위 증가 연산자를 작용합니다.

당연히, 후위 연산자이므로 최종적으로 출력될때는 계산되지 않습니다.

따라서 3+3=6으로 나옵니다.

<br>
<br>


### 3.관계 연산자 (<, >, ==, !=, >=, <=)
말 그대로 관계를 알아보는 연산자입니다. 여기서는 크기를 비교하고, 값이 같은지 다른지 확인합니다.

이를 표로 정리해보겠습니다.

분류|기능|예시
---|---|---
< |오른쪽 피연산자가 왼쪽 피연산자보다 크면 참, 작으면 거짓|a < b
> |왼쪽 피연산자가 오른쪽 피연산자보다 크면 참, 작으면 거짓|a > b
== |왼쪽 피연산자가 오른쪽 피연산자와 같으면 참, 작으면 거짓|a == b
!= |왼쪽 피연산자가 오른쪽 피연산자와 다르면 참, 작으면 거짓|a != b
>= |왼쪽 피연산자가 오른쪽 피연산자보다 크거나 같으면 참, 작으면 거짓|a >= b
<= |오른쪽 피연산자가 왼쪽 피연산자보다 크거나 같으면 참, 작으면 거짓|a <= b                                      

관계 연산자를 사용하여 예제를 만들어보겠습니다.
#### [관계 연산자를 활용한 예제]
```c#
using System;

namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 50, b = 60;
			Console.WriteLine(a < b); // 50 < 60, True
			Console.WriteLine(a > b); // 50 > 60, False
			Console.WriteLine(a == b); // 50 == 60, False
			Console.WriteLine(a != b); // 50 != 60, True
			Console.WriteLine(a >= b); // 50 >= 60, False
			Console.WriteLine(a <= b); // 50 <= 60, True
			}
	}
}
```
 
이에 따른 결과는
```
True <br>
False <br>
False <br>
True <br>
False <br>
True
```
* 관계 연산자의 결과는 반드시 참(True) 혹은 거짓(False)입니다. 
<br>
<br>

### 4.할당 연산자 (=, +=, -=, *=, /=, %=)

이 연산자는 오른쪽 피연산자를 왼쪽 피연산자에서 할당하는 역할을 합니다. 말이 어려운데, 표를 보면서 이해하겠습니다.

분류|기능|예시
---|---|---
= |오른쪽 피연산자를 왼쪽 피연산자에 할당|a = b;
+= |a += b는 a = a + b와 같음|a += b;
-= |a -= b는 a = a - b와 같음|a -= b;
*= |a *= b는 a = a * b와 같음|a *= b;
/= |a /= b는 a = a / b와 같음|a /= b;
%= |a %= b는 a = a % b와 같음|a %= b;

이를 이용하여 일단 예제를 만들어보겠습니다.

#### [할당 연산자를 활용한 예제]
```c#
using System;

namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 50, b = 60;
			a += b;
			Console.WriteLine(a);
			a -= b;
			Console.WriteLine(a);
			a *= b;
			Console.WriteLine(a);
			a /= b;
			Console.WriteLine(a);
			a %= b;
			Console.WriteLine(a);
		}
	}
}
```
이에 따른 결과는
```
110 
50
3000
50
50
```
입니다.

예를 들어, a+=b에서, a+b=110인데, 이를 a에 넣겠다는 겁니다. 즉, 오른쪽에서 먼저 계산을 마치고, <br>
계산을 마친 값을 앞의 피연산자 즉, a에게 넣은겁니다. <br>
따라서 모두 a를 출력했는데, 나오는 값이 다 다른 것입니다. 
<br>
<br>

### 5.논리 연산자 (&&,||,!)
논리 연산자는 앞의 관계 연산자처럼 값이 true 또는 false로 출력이 되는 연산자입니다.
여기서 쓰는 종류에는 논리곱(AND),논리합(OR),부정(NOT)이 있습니다. <br>
표를 보겠습니다. <br>

<논리곱 연산자(&&)의 진리표>
 A       | B       | A && B  
---|---|---
 참(T)   | 참(T)   | 참(T)  
 참(T)   | 거짓(F) | 거짓(F)
 거짓(F) | 참(T)   | 거짓(F)
 거짓(F) | 거짓(F) | 거짓(F)

논리곱 연산자 특징으로는 A와 B가 모두 참이어야 결과값으로 참이 나옵니다. <br>

<논리합 연산자(``||``)의 진리표>
 A       | B       | A (||) B  
---------|---------|---------
 참(T)   | 참(T)   | 참(T)   
 참(T)   | 거짓(F) | 참(T)
 거짓(F) | 참(T)   | 참(T) 
 거짓(F) | 거짓(F) | 거짓(F) 

논리합 연산자 특징으로는 A나 B 둘 중 하나라도 참이면 결과값으로 참이 나옵니다. <br>

<부정 연산자(!)의 진리표>
 A| !A   
---|---
 참(T)   | 거짓(F)   
 거짓(F)   | 참(T) 

부정 연산자 특징으로는 A가 참일때는 거짓, 거짓일때는 참을 출력합니다. <br>

이를 활용해서 예제를 만들겠습니다.

#### [논리 연산자를 사용한 예제]
```c#
using System;
namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 50, b = 60;
			Console.WriteLine(a > 40 && b > 50);
			Console.WriteLine(a > 40 || b > 70);
			Console.WriteLine(!(a < b));
			}
	}
} 
```
이에 따른 결과로,
```
True <br>
True <br>
False <br>
```
가 나옵니다.

첫번째 True는 a>40과 b>50 논리가 모두 참이어서 결과로 참이 출력되었고, <br>
두번째 True는 a>40 논리가 거짓이지만 b>70 논리가 참이어서 결과로 참이 출력됩니다. <br>
세번째 False는 원래 a<b 논리가 참이지만, 부정연산자로, 결과를 부정하여 거짓으로 출력합니다. <br>

#### 6.비트 연산자
말 그대로 비트를 다루는 연산자입니다. 비트에 대한 내용은 차후 **조각지식모음**에서 다루겠습니다.
 분류 | 기능                                                    | 예     
------|---------------------------------------------------------|--------
 &    | 두 피연산자의 대응되는 비트에 논리곱(AND)을 수행        | a & b  
 \|   | 두 피연산자의 대응되는 비트에 논리합(OR)을 수행         | a \| b 
 ^    | 두 피연산자의 대응되는 비트에 배타적 논리합(XOR)을 수행 | a ^ b  

일단 비트는 기본적으로 0과 1이 있습니다. 이를 이용하는 연산자인데, <br>
&연산자는 양쪽 비트가 1이어야 결과가 1이 되고, 그러지 않으면 0이 됩니다. <br>
\|연산자는 양쪽 비트 중 하나라도 1이면 결과가 1이 됩니다. <br>
^연산자는 양쪽 비트가 서로 달라야 결과가 1이 됩니다. <br>

![github](https://user-images.githubusercontent.com/81789003/129159365-9845769a-1f1b-4381-adc0-ef574b4d2327.png)

예제를 만들어보겠습니다.
 
#### [비트 연산자를 이용한 예제]
```c#
using System;

namespace Study
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 5, b = 10;
			Console.WriteLine(a & b);
			Console.WriteLine(a | b);
			Console.WriteLine(a ^ b);
		}
	}
}
```

이에 따른 결과는
```
0
15
15
```
이 나옵니다.

기본적으로 2진수를 쓰기 때문에 발생하는 현상입니다. 이에 대해서는 차후에 자세히 다루겠습니다.
<br>
<br>
### 7.시프트 연산자

이 연산자도 비트와 관련된 연산자인데, 첫번째 피연산자를 두번째 피연산자로 지정된 비트 수만큼 왼쪽(<<)으로 이동하거나 오른쪽으로(>>)으로 이동시킬 수 있습니다.

이를 이용하여 예제를 만들어보겠습니다.

#### [시프트 연산자를 활용한 예제]
```c#
using System;

namespace ConsoleApplication
{
	class Program
	{
		static void Main(string[] args)
		{
			int a = 616;
			Console.WriteLine(a << 4);
			Console.WriteLine(a >> 4);
		}
	}
}
```

결과로,
```
9856 <br>
38
```
가 나옵니다.

616는 2진수로 하면 1001101000(2)입니다. 이 비트열을 왼쪽으로 4만큼 이동시키면

10011010000000(2)이 됩니다. 이걸 다시 10진수로 만들면 9856이 됩니다. 

왼쪽으로 비트열을 이동시키면 뒤에 있는 비트들은 모두 0으로 채워집니다.

![github](https://user-images.githubusercontent.com/81789003/129159357-384e243b-5405-4416-b941-6b77c0aaef7b.png)

이를 다시 오른쪽으로 4만큼 이동시키면 100110(2)이 되고, 이를 10진수로 만들면 38이 됩니다.

본래가지고 있는 비트열에서 오른쪽으로 가면, 열을 넘어가게 되는데, 넘어가는 부분들은 버려집니다.

그리고 새로 나타나는 앞 부분 비트들은 부호 비트로 채워집니다.

(부호 비트로는 양수가 0, 음수가 1 입니다.)

![github](https://user-images.githubusercontent.com/81789003/129159373-3a67ec9f-e944-4caf-bad0-4e463b1951cc.png)

### 마무리하며
오늘은 연산자에 대한 대부분의 내용들을 배웠는데, 내용을 정리할 필요가 나을 것 같아서 표를 많이 활용하였습니다.
다음시간에는 조건문인 if,else,switch문을 배워보도록 하겠습니다.
